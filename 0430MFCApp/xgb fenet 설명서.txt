제 5 장  서비스 별 프로토콜 
5.1  개요 
5.1.1  XGB FEnet I/F 모듈의 프로토콜 개요 
XGB FEnet I/F 모듈은 개방형 이더넷(Open Ethernet)을 지원합니다. 네트워크 상에서 자사 및 타사 PLC, PC등과 연
결하여 네트워크를 구성할 수 있습니다.  
네트워크 구성 후 통신을 하기 위해서는 IP설정과 각 PLC의 파라미터 설정, 프로토콜이 설정되어야 합니다. 
XGB FEnet I/F모듈에서 지원하는 프로토콜은 XGT 전용, 모드버스 TCP/IP, 사용자 프레임 정의가 있습니다. 
각 프로토콜은 서버/클라이언트 동작에 사용되며 전용서버, P2P 기능은 지정된 프로토콜에 따라 통신을 합니다. 
5.1.2  서비스 별 프로토콜 구분 
각 프로토콜은 기능에 따라 서버/클라이언트로 구분되고 [표 5-1]과 같이 구분됩니다. 
항목 
규격 
드라이버 
통신방식 
포트번호 
비고 
UDP/IP 2005 
전용 XGT 서버 TCP/IP 2004 ▪ 최대 4채널 
모드버스 TCP 서버 
TCP/IP 
통신
기능 
TCP/IP 
XGT 클라이언트 
502 
2004 
▪ 최대 512바이트 
UDP/IP 2005 
P2P 
▪ 최대 3채널 
모드버스 TCP 클라이언트 TCP/IP 
TCP/IP 
사용자 프레임정의 
502 
사용자지정 
▪ 최대 32블록 
UDP/IP 
사용자지정 
[표 5-1] 통신기능 별 프로토콜 
5-1 
제5장 서비스 별 프로토콜 
5.2  XGT 전용 프로토콜 
5.2.1  프로토콜 개요 
XGT 전용 프로토콜은 LS산전 FEnet I/F 모듈간에 통신을 하는 프로토콜입니다. 명령어를 사용하여 읽기/쓰기가 가
능하며 PC, HMI에서 XGT 전용 프로토콜을 이용하여 통신이 가능합니다. 
XGT 전용 통신은 TCP와 UDP 두 통신 방식으로 사용이 가능합니다. 
프로토콜 
통신방식 
XGT 전용 
TCP/IP 
포트번호 
2004 
UDP/IP 
2005 
[표 5-2] XGT 전용 프로토콜 구분 
5.2.2  프레임 구조 
(1) 이더넷(Ethernet)을 통한 XGT 전용 패킷의 구조 
XGT 전용 프로토콜을 이용하여 통신시 이더넷 통신을 위한 MAC, IP 헤더(IP Header), TCP 헤더(TCP Header)와 데
이터를 포함한 LS IS 프레임 포함됩니다. 
이더넷 통신 프레임의 구조는 [그림 5-1]과 같습니다. 
Ethernet Request / Response Frame 
MAC
 IP Header
 TCP Header
 LS IS Frame Format
 TCP/IP Data Frame
 [그림 5-1] 이더넷(Ethernet)을 통한 XGT 전용 패킷 구조 
(2) XGT 전용 프레임의 구조 
데이터 통신을 위한 LS IS 프레임에는 LS 산전 고유 데이터(Company ID), 명령어(Command), 데이터 타입(Data 
Type), 데이터(Data)가 포함됩니다. 
프레임의 형태는 [그림 5-2]와 같습니다.  
LS IS Frame Format
 Company Header
 Commnad
 Data Type
 [그림 5-2] XGT 전용 프레임의 구조 
Data
 5-2 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-3 
 
5.2.3  XGT 전용 프로토콜의 헤더 구조 
항 목 크기(byte) 내용 
Company ID 10  “LSIS-XGT” + “NULL NULL(예약영역)” 
 (ASCII CODE : 4C 53 49 53 2D 58 47 54 00 00) 
PLC Info 2 
* 클라이언트  서버 : Don’ care (0x00) 
* 서버  클라이언트 : 
Bit00~05 : CPU TYPE 
01(XGK/R-CPUH), 02(XGK-CPUS), 05(XGI-CPUU) 
    Bit06 : 0 (이중화 Master / 단독),  
1(이중화 Slave) 
Bit07 : 0(CPU 동장 정상),  
1(CPU 동작 에러) 
    Bit08~12 : 시스템 상태 
      1(RUN),2(STOP), 4(ERROR), 8(DEBUG) 
Bit13~15 : Reserved 
CPU Info주1) 1 
예약영역을 통해 XGK/XGI/XGR 시리즈임을 판단합니다. - XGK: 0xA0               - XGB(MK): 0xB0 - XGI: 0XA4                - XGB(IEC): 0xB4 - XGR: 0xA8 
Source of Frame 1 * 클라이언트(HMI)  서버(PLC) : 0x33 
* 서버(PLC)  클라이언트(HMI) : 0x11 
Invoke ID 2 프레임간의 순서를 구별하기 위한 ID 
(응답 프레임에 이 번호를 붙여 보내줌) 
Length 2 Application Instruction의 바이트 크기 
FEnet Position 1 Bit0~3 : FEnet I/F 모듈의 슬롯(Slot) 번호 
Bit4~7 : FEnet I/F 모듈의 베이스(Base) 번호 
Reserved2 
(BCC) 1 0x00 : 예약영역 
(Application Header의 Byte Sum) 
[표 5-3] XGT 전용 프로토콜의 헤더 구조 
 
 
 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-4 
5.2.4  XGT 전용 프로토콜의 명령어 
XGT 전용 프로토콜에서의 사용하는 명령어는 4가지이며 각 명령어는 읽기/쓰기, 요청/응답의 처리를 합니다. 
각 명령어에서 가용 가능한 데이터 타입은 개별일 경우 비트, 바이트, 워드, 더블워드, 롱 워드가 가능하며 연속일 경
우 데이터 타입은 바이트만 가능합니다. 
 
명령어 명령어 코드 데이터형식 처리내용 
읽기 
요구: h5400 개별 
h0000 BIT 
각 데이터 타입에 따라 데이터를 읽기 요청 
h0100 BYTE 
h0200 WORD 
h0300 DWORD 
h0400 LWORD 
연속 h1400 BYTE 바이트 형의 변수를 블록 단위로 읽기 요청 
응답: h5500 개별 
h0000 BIT 
데이터를 읽기 요청에 대한 응답 
h0100 BYTE 
h0200 WORD 
h0300 DWORD 
h0400 LWORD 
연속 h1400 BYTE 블록 단위의 읽기 요청에 대한 응답 
쓰기 
요구: h5800 개별 
h0000 BIT 
각 데이터 타입에 따라 데이터를 쓰기 요청 
h0100 BYTE 
h0200 WORD 
h0300 DWORD 
h0400 LWORD 
연속 h1400 BYTE 바이트 형의 변수를 블록 단위로 쓰기 요청 
응답: h5900 개별 
h0000 BIT 
데이터를 쓰기 요청에 대한 응답 
h0100 BYTE 
h0200 WORD 
h0300 DWORD 
h0400 LWORD 
연속 h1400 BYTE 블록 단위의 쓰기 요청에 대한 응답 
[표 5-3] XGT 전용 프로토콜 명령어 타입 
 
 
 
 
 
 
 
 
 
알아두기  
(1) 타이머/카운터에서 Bit지정은 접점 값을 의미하고 Byte, Word값 지정은 현재 값을 의미합니다 
(2) 데이터 레지스터(D)는 Byte, Word로만 지정 가능합니다. 
(3) 바이트 타입 명령어의 경우 주소 값은 워드 지정시의 2배가 됩니다. 
즉, D1234의 경우 워드 지정 시 %DW1234를 사용하지만, 바이트 형태로 지정 
시 %DB2468을 사용해야 합니다. 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-5 
 
5.2.5  XGT 전용 프로토콜의 헤더 및 데이터 구조 
(1) 헤더 및 데이터 구조 
XGT 전용 프로토콜에서 LS IS 프레임에 포함되는 Company Header, Command, Data Type, Data의 내용은 다음과 같
습니다. 
 
항목 클라이언트(요청 프레임) 서버(응답 프레임) 
구분 내용 크기 구분 내용 크기 
Company 
Header 
LSIS 고유번호 Company ID 1 10 LSIS 고유번호 Company ID 1 
Company ID 2 10 
PLC 정보 h00~hFF 2 PLC 정보 h00~hFF 2 
CPU 정보 hA0 1 CPU 정보 hA0 1 
프레임 방향 h33 1 프레임 방향 h11 1 
프레임 순서번
호 h0000~hFFFF 2 프레임 순서번호 h0000~hFFFF 2 
길이 h0000~h0100 2 길이 h0000~h0100 2 
위치 정보 h00~hFF 1 위치 정보 h00~hFF 1 
체크섬 h00~hFF 1 체크섬 h00~hFF 1 
Command 명령어 h5400 읽기 2 명령어 h5500 읽기 2 h5800 쓰기 h5900 쓰기 
Data Type 데이터 타입 
h0000 비트 
2 데이터 타입 
h0000 비트 
2 
h0100 바이트 h0100 바이트 
h0200 워드 h0200 워드 
h0300 더블워드 h0300 더블워드 
h0400 롱워드 h0400 롱워드 
h1400 연속 h1400 연속 
Data 
예약 영역 - 2 예약 영역 - 2 
블록 개수 h0100~h1000 2 에러 상태 h0000~hFFFF 2 
변수 길이(N) h0400~h1000 2 데이터  2 
데이터 주소 - N  데이터 개수 h0(M)00 M 
[표 5-5] XGT 전용 프로토콜의 헤더 및 데이터 구조 
 
(2) Company ID(LS IS 고유번호) 
 LS IS(LS산전) 고유번호는 두 가지 종류가 있습니다. XGK, XGB PLC는 클라이언트로 동작 시 Company ID 1을 사용합
니다. 
서버로 동작 시에는 클라이언트가 요청하는 Company ID를 사용하며 클라이언트에서는 Company ID 1 또는 Company 
ID 2를 사용하여야 합니다. 
구분 형식 프레임 비고 
Company ID 1 ASCII L S I S - X G T /n /n XGT HEX h4C h53 h49 h53 h2D h58 h47 h54 h00 h00 
Company ID 2 ASCII L G I S - G L O F A GM,MK HEX h4C h47 h49 h53 h2D h47 h4C h4F h46 h41 
[표 5-6] LS IS 고유번호 
 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-6 
5.2.6  프레임의 예 
(1) 변수 개별 읽기 요청 프레임 
구분 형식 프레임 크기 
LSIS 고유번호 Company ID 
ASCII L S I S - X G T \n \n  
10 HEX 0x4C 0x53 0x49 Ox53 Ox2D 0x58 0x47 0x54 0x00 0x00  
ASCII L G I S - G L O F A  
HEX 0x4C 0x47 0x49 0x53 0x2D 0x47 0x4C 0x4F 0x46 0x41  
PLC  정보 PLC Info HEX 0x00 0x00          2 
CPU 정보 CPU Info 
HEX 
0xA0           1 
프레임 방향 Source of Frame 0x33           1 
프레임 순서번호 Invoked ID 0x00 0x00          2 
길이 Length 0x0E 0x00          2 
위치 정보 Position 0x00           1 
체크섬 Check Sum 0x4E           1 
명령어 Command 0x54 0x00          2 
데이터 타입 Data Type 0x02 0x00          2 
예약 영역 Reserved 0x00 0x00          2 
블록 개수 Block No. 0x01 0x00          2 
변수 길이 Variable Length 0x04 0x00          2 
데이터 주소 Data Address ASCII % M W 0        4 HEX 0x25 0x4D 0x57 0x30        
[표 5-7] 변수 개별 읽기 요청 프레임 
 
(2) 변수 개별 읽기 응답 프레임 
구분 형식 프레임 크기 
LSIS 고유번호 Company ID 
ASCII L S I S - X G T \n \n  
10 HEX 0x4C 0x53 0x49 Ox53 Ox2D 0x58 0x47 0x54 0x00 0x00  
ASCII L G I S - G L O F A  
HEX 0x4C 0x47 0x49 0x53 0x2D 0x47 0x4C 0x4F 0x46 0x41  
PLC  정보 PLC Info 
HEX 
0x11 0x01          2 
CPU 정보 CPU Info 0xA0           1 
프레임 방향 Source of Frame 0x11           1 
프레임 순서번호 Invoked ID 0x00 0x00          2 
길이 Length 0x0E 0x00          2 
위치 정보 Position 0x03           1 
체크섬 Check Sum 0x2F           1 
명령어 Command 0x55 0x00          2 
데이터 타입 Data Type 0x02 0x00          2 
예약 영역 Reserved 0x08 0x01          2 
에러 상태 Error State 0x00 0x00          2 
변수 길이 Variable Length 0x01 0x00          2 
데이터 개수 Data Count 0x02 0x00          2 
데이터 Data 0x00 0x00          2 
[표 5-8] 변수 개별 읽기 응답 프레임 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-7 
 
(3) 변수 연속 읽기 요청 프레임 
구분 형식 프레임 크기 
LSIS 고유번호 Company ID 
ASCII L S I S - X G T \n \n  
10 HEX 0x4C 0x53 0x49 Ox53 Ox2D 0x58 0x47 0x54 0x00 0x00  
ASCII L G I S - G L O F A  
HEX 0x4C 0x47 0x49 0x53 0x2D 0x47 0x4C 0x4F 0x46 0x41  
PLC  정보 PLC Info HEX 0x00 0x00          2 
CPU 정보 CPU Info 
HEX 
0xA0           1 
프레임 방향 Source of Frame 0x33           1 
프레임 순서번호 Invoked ID 0x00 0x01          2 
길이 Length 0x10 0x00          2 
위치 정보 Position 0x00           1 
체크섬 Check Sum 0x3F           1 
명령어 Command 0x54 0x00          2 
데이터 타입 Data Type 0x14 0x00          2 
예약 영역 Reserved 0x00 0x00          2 
블록 개수 Block No. 0x01 0x00          2 
변수 길이 Variable Length 0x04 0x00          2 
데이터 주소 Data Address ASCII % M B 0        4 HEX 0x25 0x4D 0x42 0x30        
데이터 개수 Data Count HEX 0x02 0x00          2 
[표 5-9] 변수 연속 읽기 요청 프레임 
 
(4) 변수 연속 읽기 응답 프레임 
구분 형식 프레임 크기 
LSIS 고유번호 Company ID 
ASCII L S I S - X G T \n \n  
10 HEX 0x4C 0x53 0x49 Ox53 Ox2D 0x58 0x47 0x54 0x00 0x00  
ASCII L G I S - G L O F A  
HEX 0x4C 0x47 0x49 0x53 0x2D 0x47 0x4C 0x4F 0x46 0x41  
PLC  정보 PLC Info 
HEX 
0x02 0x08          2 
CPU 정보 CPU Info 0xA0           1 
프레임 방향 Source of Frame 0x11           1 
프레임 순서번호 Invoked ID 0x00 0x01          2 
길이 Length 0x0E 0x00          2 
위치 정보 Position 0x01           1 
체크섬 Check Sum 0x26           1 
명령어 Command 0x55 0x00          2 
데이터 타입 Data Type 0x14 0x00          2 
예약 영역 Reserved 0x00 0x00          2 
에러 상태 Error State 0x00 0x00          2 
변수 길이 Variable Length 0x01 0x00          2 
데이터 개수 Data Count 0x02 0x00          2 
데이터 Data 0x00 0x00          2 
[표 5-10] 변속 연속 읽기 응답 프레임 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-8 
 
5.3  모드버스 TCP/IP 프로토콜 
 
5.3.1  프로토콜 개요 
모드버스 TCP/IP 프로토콜은 펑션코드를 이용하여 데이터 읽기/쓰기를 하는 기능입니다. 모드버스 TCP/IP 프레임은 
이더넷 통신을 위한 MAC, IP헤더, TCP헤더, 모드버스 ADU로 구성됩니다. 
 
(1) ADU: 애플리케이션 데이터 유닛(Application Data Unit) 
(2) MBAP: 모드버스 애플리케이션 프로토콜(ModBus Application Protocol) 
(3) PDU: 프로토콜 데이터 유닛(Protocol Data Unit) 
 
5.3.2  모드 버스 TCP/IP 프레임 구조 
(1) 이더넷(Ethernet)을 통한 모드버스 TCP/IP 프레임 구조 
IP Header MAC TCP Header MODBUS TCP/IP ADU
 MODBUS TCP/IP ADU
 Ethernet Request / Response Frame 
 
[그림 5-3] 이더넷(Ethernet)을 통한 모드버스 프레임 구조 
 
 
MABP Header
 Transaction Identifier Protocol Identifier Length Unit Identifier
 
[그림 5-4] 모드버스 TCP/IP ADU 구조 
 
MABP Header Function Code Data
 MODBUS TCP/IP ADU
 PDU 
[그림 5-5] 모드버스 ADU의 구조 
 
 
 
 
 
 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-9 
5.3.3  MBAP Header 구조 
 
구분 크기 설명 클라이언트 서버 
처리 식별자 
(Transaction 
Identifier) 
2바이트 MODBUS 요구 /응답 
처리 구분  클라이언트가 초기화 서버가 응답 시 복사하
여 응답 
프로토콜 식별자
(Protocol Identifier) 
2바이트 0 = MODBUS 프로토콜 클라이언트가 초기화 서버가 응답 시 요청프
레임에서 복사 
2바이트 MBAP를 제외한 프레임 
크기 클라이언트가 생성 (요청 시) 서버가 생성 
(응답 시) 
유닛 식별자 
(Unit Identifier) 1바이트 시리얼 선로에 연결되
어 있는 유닛 구분 클라이언트가 초기화 서버가 응답 시 요청프
레임에서 복사 
[표 5-11] MBAP 헤더 구조 
 
5.3.4  사용 가능 펑션 코드 
 
펑션 코드 구분 기능 모드버스 표기 
Function Code 01 (h01) 출력 비트 읽기 Read Coils 
Function Code 02 (h02) 입력 비트 읽기 Read Discrete Inputs 
Function Code 03 (h03) 출력 워드 읽기 Read Holding Registers 
Function Code 04 (h04) 입력 워드 읽기 Write Input Register 
Function Code 05 (h05) 출력 비트 쓰기 Write single Coil 
Function Code 15 (h0F) 출력 비트 연속 쓰기 Write Multiple Coils  
Function Code 16 (h10) 출력 워드 연속 쓰기 Write Multiple Registers 
[표 5-12] 펑션 코드 일람 
 
 
5.3.5  펑션 코드 별 프레임 구조 
(1) 펑션 코드 h01: 출력 비트 읽기(Read Coils) 
 요청 (Request)  
구분 크기 범위 
펑션 코드 1 바이트 h01 
시작 주소 2 바이트 h0000 ~ hFFFF 
코일 수 2 바이트 h0001 ~ h07D0 (2000 비트) 
[표 5-13] 펑션 코드 h01 요청 프레임 
   
응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h01 
바이트 수 2 바이트 N 
코일 상태 n 바이트 n = N 또는 N + 1 
[표 5-14] 펑션 코드 h01 응답 프레임 
      
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-10 
 
에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h81 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-15] 펑션 코드 h01 에러 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h01 펑션 코드 h01 
시작 주소(상위 바이트) h00 바이트 수 h03 
시작 주소(하위 바이트) h13 코일 상태(27-20) hCD 
코일 수(상위 바이트) h00 코일 상태(36-28) h6B 
코일 수(하위 바이트) h13 코일 상태(38-36) h05 
[표 5-16] 펑션 코드 h01 프레임의 예 
 
(2) 펑션 코드 h02: 입력 비트 읽기(Read Discrete Inputs) 
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h02 
시작 주소 2 바이트 h0000 ~ hFFFF 
입력 수 2 바이트 h0001 ~ h07D0 (2000 비트) 
[표 5-17] 펑션 코드 h02 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h02 
바이트 수 2 바이트 N 
입력 상태 N x 1 바이트 - 
[표 5-18] 펑션 코드 h02 응답 프레임 
 에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h82 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-19] 펑션 코드 h02 응답 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h02 펑션 코드 h02 
시작 주소(상위 바이트) h00 바이트 수 h03 
시작 주소(하위 바이트) hC4 코일 상태(27-20) hCD 
입력 상태(상위 바이트) h00 코일 상태(36-28) h6B 
코일 수(하위 바이트) h16 코일 상태(38-36) h05 
[표 5-20] 펑션 코드 h02 요청 프레임의 예 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-11 
 
(3) 펑션 코드 h03: 출력 워드 읽기(Read Holding Registers)  
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h03 
시작 주소 2 바이트 h0000 ~ hFFFF 
입력 수 2 바이트 h0001 ~ h007D (125워드) 
[표 5-21] 펑션 코드 h03 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h03 
바이트 수 2 바이트 2 x N 
입력 상태 N x 2 바이트 - 
[표 5-22] 펑션 코드 h03 응답 프레임 
 에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h83 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-23] 펑션 코드 h03 에러 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h03 펑션 코드 h03 
시작 주소(상위 바이트) h00 바이트 수 h06 
시작 주소(하위 바이트) h6B 워드 상태(108) h02 
워드 개수(상위 바이트) h00 워드 상태(108) h2B 
워드 개수(하위 바이트) h03 워드 상태(109) h00 
 
워드 상태(109) h00 
워드 상태(110) h00 
워드 상태(110) h64 
[표 5-24] 펑션 코드 h03 프레임의 예 
 
(4) 펑션 코드 h04: 입력 워드 쓰기(Read Input Registers) 
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h04 
시작 주소 2 바이트 h0000 ~ hFFFF 
입력 수 2 바이트 h0001 ~ h007D (125워드) 
[표 5-25] 펑션 코드 h04 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h04 
바이트 수 2 바이트 2 x N 
입력 상태 N x 2 바이트 - 
[표 5-26] 펑션 코드 h04 응답 프레임 
  
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-12 
에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h84 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-27] 펑션 코드 h04 에러 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h04 펑션 코드 h04 
시작 주소(상위 바이트) h00 바이트 수 h02 
시작 주소(하위 바이트) h08 워드 상태(108) h00 
워드 개수(상위 바이트) h00 워드 상태(108) h0A 
워드 개수(하위 바이트) h01  
[표 5-28] 펑션 코드 h04 프레임의 예 
 
(5) 펑션 코드 h05: 출력 비트 쓰기(Write Single Coil) 
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h05 
시작 주소 2 바이트 h0000 ~ hFFFF 
입력 값 2 바이트 h0000 또는 hFF0D  
[표 5-29] 펑션 코드 h05 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h05 
바이트 수 2 바이트 h0000 ~ hFFFF 
입력 상태 2 바이트 h0000 또는 hFF00 
[표 5-4] 펑션 코드 h05 응답 프레임 
 에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h85 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-5] 펑션 코드 h05 에러 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션코드 h05 펑션 코드 h05 
시작 주소(상위 바이트) h00 바이트 수 h03 
시작 주소(하위 바이트) hC4 코일 상태(27-20) hCD 
입력 상태(상위 바이트) h00 코일 상태(36-28) h6B 
코일 수(하위 바이트) h16 코일 상태(38-36) h05 
[표 5-6] 펑션 코드 h05 프레임의 예 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-13 
 
(6) 펑션 코드 h0F: 출력 워드 연속 쓰기(Write Multiple Registers) 
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h0F 
시작 주소 2 바이트 h0000 ~ hFFFF 
출력 개수 2 바이트 h0001 ~ h07BD  
바이트 개수 1 바이트 N 
출력 값 N x 1 바이트  
[표 5-7] 펑션 코드 h0F 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h0F 
바이트 수 2 바이트 h0000 ~ hFFFF 
입력 상태 2 바이트 h0001 ~ h07B0 
[표 5-8] 펑션 코드 h0F 응답 프레임 
 에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h8F (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-9] 펑션 코드 h0F 요청 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h0F 펑션 코드 h0F 
시작 주소(상위 바이트) h00 시작 주소(상위 바이트) h00 
시작 주소(하위 바이트) h13 시작 주소(하위 바이트) h13 
출력 개수(상위 바이트) h00 출력 개수(상위 바이트) h00 
출력 개수(하위 바이트) h0A 출력 개수(하위 바이트) h0A 
바이트 수 h02 
 출력 값(상위 바이트) hCD 
출력 값(하위 바이트) h01 
[표 5-10] 펑션 코드 h0F 요청 프레임의 예 
제5장 서비스 별 프로토콜 
구분 
(7) 펑션 코드 h06: 출력 워드 쓰기(Write Single Register) 
요청 (Request) 
크기 
펑션 코드 
시작 주소 
1 바이트 
범위 
h06 
2 바이트 
출력 값 
h0000 ~ hFFFF 
2 바이트 
h0000 또는 hFFFF  
[표 5-11] 펑션 코드 h06 요청 프레임 
응답 (Response) 
구분 
크기 
범위 
펑션 코드 
시작 주소 
1 바이트 
h06 
2 바이트 
출력 값 
h0000 ~ hFFFF 
2 바이트 
h0000 또는 hFFFF 
[표 5-12] 펑션 코드 h06 응답 프레임 
에러 (Error) 
사용의 예 
구분 
크기 
범위 
펑션 코드 
예외 코드 
1 바이트 
h86 (펑션 코드 + h80) 
1 바이트 
h01,h02,h03,h04 
[표 5-13] 펑션 코드 h06 에러 프레임 
요청 프레임 
응답 프레임 
구분 
HEX 
구분 
펑션 코드 h06 
펑션 코드 
HEX 
h06 
시작 주소(상위바이트) h00 
바이트 수 
시작 주소(하위바이트) h01 
코일 상태(27-20) 
h00 
h01 
입력 상태(상위바이트) h00 
코일 상태(36-28) 
코일 수(하위바이트) h03 
코일 상태(38-36) 
h00 
[표 5-14] 펑션 코드 h06 프레임의 예 
h03 
5-14 
 
 
 
 
제5장 서비스 별 프로토콜 
 
5-15 
 
(8) 펑션 코드 h10: 출력 연속 쓰기(Write Multiple Registers) 
 요청 (Request) 
구분 크기 범위 
펑션 코드 1 바이트 h10 
시작 주소 2 바이트 h0000 ~ hFFFF 
출력 개수 2 바이트 h0001 또는 h07D8  
바이트 수 1 바이트 2 x N 
출력 값 N x 2 바이트 값 
[표 5-15] 펑션 코드 h10 요청 프레임 
 응답 (Response) 
구분 크기 범위 
펑션 코드 1 바이트 h10 
바이트 수 2 바이트 h0000 ~ hFFFF 
출력 개수 2 바이트 h0001 ~ h007B 
[표 5-16] 펑션 코드 h10 응답 프레임 
 에러 (Error) 
구분 크기 범위 
펑션 코드 1 바이트 h90 (펑션 코드 + h80) 
예외 코드 1 바이트 h01,h02,h03,h04 
[표 5-17] 펑션 코드 h10 에러 프레임 
 사용의 예 
요청 프레임 응답 프레임 
구분 HEX 구분 HEX 
펑션 코드 h10 펑션 코드 h10 
시작 주소(상위 바이트) h00 시작 주소(상위 바이트) h00 
시작 주소(하위 바이트) h01 시작 주소(하위 바이트) h01 
출력 개수(상위 바이트) h00 출력 개수(상위 바이트) h00 
출력 개수(하위 바이트) h02 출력 개수(하위 바이트) h02 
바이트 수 h04 
 
출력 값(상위 바이트) h00 
출력 값(하위 바이트) h0A 
출력 값(상위 바이트) h01 
출력 값(하위 바이트) h02 
[표 5-18] 펑션 코드 h10 프레임의 예 
 
 
제6장 전용 서비스 
제 6 장  전용 서비스 
6.1  전용 서비스 기능의 개요 
6.1.1  서버 모델 
전용서비스는 아래의 [그림 6-1] 클라이언트/서버 모델에서 서버 기능을 의미합니다. 클라이언트가 접속하여 설정한 
프로토콜에 따라 데이터 읽기/쓰기를 하는 동작을 합니다. 
(1) 클라이언트/서버 모델 
서버는 ② 수신감지와 ③ 응답전송의 기능을 수행합니다. 
① 요청 전송
클라이언트
(Request)
 ④ 처리 확정
(Client)
 (Confirmation)
 ② 수신 감지
(Indication)
 ③ 응답 전송
(Response)
 [그림 6-1] 클라이언트/서버 모델 
6.1.2  시스템 구성 
6.1.3  전용서비스 구분 
전용서비스 구분 
①
클라이언트
(Client)
 ②
클라이언트
(Client)
 ③
클라이언트
(Client)
 ④
클라이언트
(Client)
 [그림 6-2] 클라이언트/서버 시스템 구성 
서버
(Server)
네트워크
 (Network)
포트번호 
XGT 서버 TCP XGT 서버 
2004 
프로토콜 구분 
TCP 
최소/최대 접속개수 
UDP XGT 서버 
2005 
UDP 
1/4 
모드버스 TCP/IP 서버 
1/4 
502 
TCP 
[표 6-1] 전용서비스 구분


XGT FEnet I/F 모듈 프로토콜 규격 
1 전용통신 
1.1 개 요 
전용통신 서비스는 FEnet I/F 모듈에 내장된 프로토콜로 PC 및 주변기기에서 PLC 내의 
정보  
및 데이터를 읽고 쓸 수 있는 서비스 입니다. 통신 네트워크에서 슬레이브로 동작하게  
되며 외부 기기 나 PC에서의 XGT 프로토콜이나 모드버스 TCP 프로토콜을 따르는 메모리  
읽기, 쓰기 요청이 올 경우 응답 합니다 (XGT 전용 드라이버와 MODBUS TCP 드라이버  
지원) FEnet I/F 모듈의 XGT 전용 드라이버를 위한 TCP포트 2004와 UDP 포트 2005를  
이용하고 있으며, MODBUS TCP 드라이버는 TCP 502를 이용하고 있습니다. 
자사 Ethernet 모듈 사이의 통신, 상위 시스템(PC 프로그램, MMI)과 자사의 Ethernet 모듈  
사이의 통신에 유용하게 사용 할 수 있습니다.  
1) XGT 전용 드라이버 설정 
Ethernet 통신을 하기 위해서는 반드시 기본파라미터를 설정해서 다운로드 한 뒤에 
사용해야 하듯이, 전용 서비스를 이용해서 통신을 하려면 반드시 설정 후 다운로드 해야 
합니다. (설정하지 않았을 경우 XGT SERVER) 
기본 파라미터 내에 전용 접속 개수는 자사의 전용 포트(2004)를 이용해서 맺어진 
채널(MMI 접속) 개수를 의미합니다. 따라서 프레임 편집기의 전용 접속 개수를 
변환함으로써 자사의 전용 통신용 채널 접속 개수 변경 할 수 있습니다.  
2/21 
XGT FEnet I/F 모듈 프로토콜 규격 
 
3/21 
 
 
 
1.2 프레임 구조 
자사 Ethernet 모듈의 어플리케이션 프레임의 구조를 아래에 나타냅니다.  
Header 
IP Header TCP Header 
  
 
Application Data Format 
Application Header Format Application Instruction Format 
 
1) 헤더 구조(Application Header Format) 
 
항 목 크기(byte) 내용 
Company ID 8  “LSIS-XGT” 
 (ASCII CODE : 4C 53 49 53 2D 58 47 54 00 00) 
Reserved 2 0x00 : 예약영역 
PLC Info 2 
* 클라이언트(MMI)  서버(PLC) : Don’ care (0x00) 
* 서버(MMI)  클라이언트(PLC) : 
  1) Reserved1이 0x00인 경우 
Bit00~05 : CPU TYPE 
01(XGK-CPUH), 02(XGK-CPUS) 
    Bit06 : 0 (이중화 Master / 단독),  
1(이중화 Slave) 
Bit07 : 0(CPU 동장 정상),  
1(CPU 동작 에러) 
    Bit08~12 : 시스템 상태 
      2(STOP), 4(RUN), 8(PAUSE), 10(DEBUG) 
Bit13~15 : Reserved 
CPU Info 1 0xA0 주1) 
Source of Frame 1 * 클라이언트(MMI)  서버(PLC) : 0x33 
* 서버(PLC)  클라이언트(MMI) : 0x11 
Invoke ID 2 Frame간의 순서를 구별하기 위한 ID 
(응답 프레임에 이 번호를 붙여 보내줌) 
Length 2 Application Instruction의 바이트 크기 
FEnet Position 1 
Bit0~3 : FEnet I/F 모듈의 슬롯(Slot) 번호 
Bit4~7 : FEnet I/F 모듈의 베이스(Base) 번호 
Reserved2 
(BCC) 1 0x00 : 예약영역 
(Application Header의 Byte Sum) 
     주1) Reserved 영역을 통해 XGK/XGI 시리즈임을 판단 
 
 
XGT FEnet I/F 모듈 프로토콜 규격 
2) 프레임 기본 구조(Application Instruction Format) 
(1) 헤더 
Company 
ID 
(‘LSIS
XGT’) 
PLC  
정보 
영역(2) 
예약
(1) 
H33
 (1) 
예약 
영역 
BCC
 (1) 
         *
 Invoke ID
 (2) 
* ( ) 괄호 안의 수는 바이트 개수 
▷ Company ID : 아스키 문자열로 ‘LSIS-XGT’ 
▷ PLC Info  PLC 에 대한 정보 영역 
Length 
(2) 
(1) 
▷ Invoke ID : 프레임간의 순서를 구별하기 위한 ID 로 명령 요구 시 임의로 
지정할 수 있으며, 응답 프레임은 명령 요구 시 수신된 Invoke 
ID 를 재송신 합니다.(PC 나 MMI 에서 에러 체크를 위해서 
사용하는 영역) 
▷ Length : 프레임 중 헤더 뒤에 오는 데이터 영역의 길이 
(2) 명령 요구 프레임(외부 통신 기기 → FEnet I/F 모듈) 
헤더 
명령어 
구조화된 
데이터 영역 
데이터 
타입 
예약영역 
(2 바이트) 
(3) ACK 응답 프레임(FEnet 모듈 → 외부 통신 기기, 데이터 정상 수신 시) 
헤더 명령어 데이터 
구조화된  
데이터 영역 
타입 
예약영역 
(2 바이트)
에러상태(2바
이트 h’0000) 
(4) NAK 응답 프레임(FEnet 모듈 → 외부 통신 기기, 데이터 비정상 수신 시) 
헤더 명령어 데이터 
에러 코드 
(1 바이트) 
타입 
알아두기 
예약영역 
(2 바이트)
에러상태 
(2 바이트: 
h’0000 가 아님) 
1) 프레임 내의 숫자 앞에 16진수 데이터인 경우01, h’12345, h’34, 0x12, 0x89AB와  
같이 ‘h’’또는 ‘0x’에 의해 이 데이터가 16진수 타입 임을 표시합니다. 
4/21 
XGT FEnet I/F 모듈 프로토콜 규격 
1.3 명령어 일람 
전용 통신 서비스에서 사용되는 명령들은 아래 표와 같습니다. 
명령어 
명령어 코드 
데이터
형식 
처 리 내 용 
개별 Bit, Byte, Word, Dword, Lword형의 변수의 각 데이터
읽기 요구 :h’0054 
타입에 따라 데이터를 읽어 옵니다 
응답 :h’0055 
연속 바이트 형의 변수를  블록 단위로 읽어옵니다. 
(최대 1,400 바이트). 
개별 Bit, Byte, Word, Dword, Lword형의 변수의 각 데이터
쓰기 요구 :h’0058 
응답 :h’0059 
타입에 따라 데이터를 씁니다. 
연속 바이트 형의 변수를 블록 단위로 씁니다. 
(최대 1,400 바이트). 
[표 1.1] 명령어 일람 
1.4 데이터 타입 
1) 변수의 데이터 종류 
XGT PLC 의 메모리 디바이스 종류 : P, M, L, F, K, C, D, T, N, R등의 변수에 대한 데이터 
타입은 변수 표시 문자 ‘%’ 다음에 표시 합니다. 
데이터 타입 
사용 예. 
Bit %PX0,%LX0,%FX0 
Byte 
%MB0, %PB0, %DB0 
Word %PW0,%LW0,%FW0,%DW0 
DWord %PD0,%LD0,%FD0,%DD0 
LWord %PL0,%LL0,%FL0,%DL0 
[표 1.2] 직접변수의 데이터 종류 일람 
2) 데이터 타입 
직접변수를 읽거나 쓰고자 할 경우 명령어 타입으로 데이터 타입을 지정합니다. 
데이터 타입 
코드 
데이터 타입 
BIT 
h’00 
LWORD 
코드 
BYTE 
h’04 
h’01 
DWORD 
WORD 
h’03 
h’02 
LWORD 
DWORD 
h’04 
h’03 
연속 
 [표 1.3] 직접변수의 데이터 타입 일람 
h’14 
5/21 
XGT FEnet I/F 모듈 프로토콜 규격 
2. 명령어 실행 
2.1 변수 개별 읽기 
1) 개 요 
PLC 디바이스 메모리를 직접 지정하여 메모리 데이터 타입에 맞게 읽는 기능입니다. 한 
번에 16개의 독립된 디바이스 메모리를 읽을 수 있습니다. 
2) 요구 포맷(PC -> PLC)      
■ 개별 변수 읽기 요구 (MMI 
항 목 
크기(byte) 
 PLC) 
내용 
명령어 
2 
데이터 타입 
0x0054 : Read Request 
Data Type 표 참조(X,B,W,D,L) 
예약 영역 
2 
2 
0x0000 : Don’t Care. 
변수 개수 
읽고자 하는 Variable의 개수 최대 16개 
변수명 길이 
2 
2 
직접변수의 길이. 최대 16자. 
변수 
... ... 
2 
변수명 길이 직접변수만 사용가능 
(변수 개수만큼 반복/최대 16) 
변수명 길이 
변수 
직접변수의 길이. 최대 16자. 
변수명 길이 직접변수만 사용가능 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
직접  
변수 
코드(예)  
블록수 
변수  
길이 
... 
h’0054 h’0002 h’0000 
(1) 블록 수 
h’0001 h’0006 %MW100 
                                               1
블록(최대 16 블록 까지 반복 설정 가능) 
이것은 ‘[변수 길이][변수]’으로 구성된 블록이 이 요구 포맷에 몇 개가 있는지를  
지정하는 것으로 최대 16개의 블록까지 설정할 수 있습니다. 따라서 [블록수]의 값은  
h’0001 ~ h’0010 이어야 합니다. 
(2) 변수 길이(변수 이름 길이) 
변수를 의미하는 이름의 글자 수를 나타내는 것으로 최대 16자까지 허용됩니다.  
이 값의 범위는 h’01에서 h’10까지 입니다. 
6/21 
XGT FEnet I/F 모듈 프로토콜 규격 
(3) 변수 
실제로 읽어올 변수의 어드레스를 입력합니다. 16자 내의 아스키 값이어야 하며, 이  
변수 이름에는 숫자, 대/소문자 , ‘%’ 및 ’.’이외에는 허용되지 않습니다. 
PLC 타입에 따라 사용 가능한 변수를 아래 표에 표시 하였습니다. 
구 분 
Bool 
Byte 
XGT 메모리 %(P,M,L,K,F,T)X
 Word 
Double Word 
Long Word - 
%(P,M,L,K,F,
 T,C,D,S)W 
[표 2.1] 변수 종류 
알아두기 - - 
1) 프레임 작성 시 위의 프레임에서 16 진수 워드 데이터를 표현할 때는 숫자 앞의 h를 
빼고, 두 바이트의 위치를 바꾸어 주어야 합니다. 
예) h’0054 ⇒5400 
3) 응답 포맷(PLC가 ACK 응답 시) 
■ 개별 변수 읽기 응답 (PLC 
항 목 
크기(byte) 
MMI) 
내용 
명령어 
2 
데이터 타입 
0x0055 : Read Response 
Data Type 표 참조 
예약 영역 
2 
2 
0x0000 : Don’t Care 
에러 상태 
2 
0 이면 정상,  0이 아니면 에러 
에러 정보
2 
 Error State 가 에러인 경우 하위 Byte가 에러 번호 
변수 개수  
데이터 크기 
2 
Error State 가 정상인 경우 읽어온 Variable의 개수  
Data 의 Byte Size. 
데이터 데이터 크기 읽어온 Data. 
... ... 
데이터 크기 
2 
(변수 개수만큼 반복/최대 16) 
Data 의 Byte Size. 
데이터 데이터 크기 읽어온 Data. 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
에러 
상태 
코드(예) 
... 
h’0055 
블록수
데이터 
개수 
데이터 
...... 
h’0002 h’0000 h’0000 
7/21 
h’0001 h’0002 h’1234 
                                                       1
블록(최대 16 블록) 
XGT FEnet I/F 모듈 프로토콜 규격 
(1) 데이터 개수 
HEX형의 바이트 개수를 의미합니다. 이 개수는 컴퓨터 요구 포맷의 변수 이름에  
포함되어 있는 메모리 타입(X,B,W,D,L)에 따라 결정됩니다 
(2) 블록 수 
이것은 ‘[데이터개수][데이터]’로 구성된 블록이 이 요구 포맷에 몇 개가 있는지를  
지정하는 것으로 최대 16개 블록까지 설정할 수 있습니다. 따라서 [블록수]의 값은  
h’0001~ h’0010 이어야 합니다. 
구 분 
가능한 변수 
Bool(X) %(P,M,L,K,F,T)X 
데이터 개수(Byte) 
1 
( 최하위 비트만 유효) 
Word(W) %(P,M,L,K,F,T,C,D,S)W 2 
[표 2.2] 변수에 따른 데이터 개수 
알아두기 
1) 데이터 개수가 H04 라는 의미는 데이터에 4바이트의 16 진수(HEX)데이터가 있음(Double 
Word)을 표시합니다. 
1) 
데이터 타입이  Bool인 경우 읽은 데이터는 한 Byte(HEX)로 표시됩니다. 즉 BIT값이  
0 이면 h’00으로, 1이면 h’01로 표시됩니다. 
4) 응답 포맷(NAK 응답 시) 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약영역
에러 코드 
에러상태 
(Hex 1 Byte) 
코드(예) 
... h’0055 
h’0002 
h’0000 
알아두기 
h’FFFF 
(0 이 아닌 값) 
h’21 
1) 에러코드는 헥사로 1 바이트의 내용으로 에러의 종류를 표시합니다. 
자세한 내용은 ‘에러코드 표’ 참조하십시오. 
8/21 
XGT FEnet I/F 모듈 프로토콜 규격 
2.2 변수 연속 읽기 
1) 개 요 
PLC 디바이스 메모리를 직접 지정하여 지정된 번지부터 지정된 양 만큼의 데이터를 
연속으로 읽는 기능 입니다. 
2) 요구포맷(PC ⇒ PLC) 
■ 연속변수 읽기 요구 (MMI 
항 목 
크기(byte) 
 PLC) 
내용 
명령어 
2 
0x0054 : Read Request 
데이터 타입 
2 
0x0014 : Block Type 
예약 영역 
2 
변수 개수 
0x0000 : Don’t Care. 
읽고자 하는 Variable의 개수 최대 16개 
변수명 길이 
2 
2 
변수명의 길이. 최대 16자. 
Variable 명. 바이트 타입 직접변수만 사용가능.  
(즉, %MB / %PB / %DB….. 형태 가능: 
변수 
변수명 길이 
지원 디바이스:P,N,L,K,T,C,D,N, F)  
블록의 선두 번지를 나타냄. (예. %MB0, %PB0) 
변수명 길이 
2 
Data 의 Byte Size, 최대 1400byte 
포맷이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
블록수 
변수 
길이 
직접 
변수 
코드(예) 
... 
h’0054 
데이터 
개수 
h’0014 h’0000 h’0001 
알아두기 
h’0006 
%MWOO
 O 
h’0006 
1) 데이터 개수는 데이터의 바이트 개수를 의미합니다(최대 1,400 바이트). 
(1) 데이터 타입 
데이터 타입은 h’0014로만 사용할 수 있습니다. 
(2) 블록수 
블록 수는 반드시 h’0001로만 사용할 수 있습니다. 
(3) 변수 길이 
9/21 
XGT FEnet I/F 모듈 프로토콜 규격 
변수를 의미하는 이름의 자 수를 나타내는 것으로 최대 16자까지 허용되며  
범위는 h’0001에서 h’0010까지 입니다. 
(4) 변수 
실제로 읽어올 변수의 어드레스를 말하며 16자 내의 아스키 값이어야 하고 변수  
이름에는 숫자,대소문자, ‘%’ 및 ’.’이외에는 허용되지 않습니다. 변수의 연속  
읽기에 가능한 변수 종류는 PLC 타입에 따라 가능한 종류를 아래 표에 표시하였습니 
다. 
3) 응답 포맷(PLC ACK 응답 시) 
■ 연속 변수 읽기 응답 (PLC 
항 목 
크기(byte) 
MMI) 
명령어 
2 
내용 
데이터 타입 
0x0055 : Read Response 
0x0014 : 블록 타입 
예약 영역 
2 
2 
0x0000 : Don’t Care 
에러 상태 
2 
0 이면 정상,  0이 아니면 에러 
에러 정보
2 
 Error State 가 에러인 경우 하위 Byte가 에러 번호 
변수 개수  
데이터 크기 
2 
0x0001 : Error State 가 정상인 경우  
Data 의 Byte Size. 
데이터 데이터 크기 읽고자 하는 Data, 최대 1400byte 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
에러 
상태 
블록수 
코드(예) 
... 
h’0055 
데이터 
개수 
데이터 
h’0123456
 789AB 
h’0014 h’0000 h’0000 
▷ 데이터 개수는 헥사형의 바이트 개수를 의미합니다. 
4) 응답 포맷 (PLC NAK 응답 시) 
포맷 
이름 
헤더 
명령어 
데이터 타입
예약영역 
h’0001 
h’0006 
에러코드 
에러상태 
코드(예) 
... h’0055 
h’0014 
(Hex 1Byte) 
h’0000 
알아두기 
h’FFFF 
h’21 
1) 에러코드는 HEX로 1 바이트의 내용으로 에러의 종류를 표시합니다. 
자세한 내용은 ‘에러코드 표’ 참조하십시오. 
10/21 
XGT FEnet I/F 모듈 프로토콜 규격 
2.3 변수 개별 쓰기 
1) 개 요 
PLC 디바이스 메모리를 직접 지정하여 메모리 데이터 타입에 맞게 쓰는 기능입니다. 
한번에 16개의 독립된 디바이스 메모리에 데이터를 쓸 수 있습니다. 
2) 요구 포맷(PC -> PLC)  
■ 개별 변수 쓰기 요구 (MMI 
항 목 
크기(byte) 
 PLC) 
명령어 
내용 
2 
데이터 타입 
0x0058 : Write Request 
Data Type 표 참조 
예약 영역 
2 
2 
0x0000 : Don’t Care. 
변수 개수 
쓰고자 하는 Variable의 개수. 최대 16개. 
변수명 길이 
2 
2 
직접변수의 길이. 최대 16자. 
변수명 
... ... 
2 
변수명 길이 직접변수만 사용가능 
(변수 개수만큼 반복/최대16) 
변수명 길이 
변수명 
직접변수의 길이. 최대 16자. 
데이터 크기 
변수명 길이 직접변수만 사용가능 
Data 의 Byte Size. 
데이터 
2 
데이터 크기 쓸 Data. 
... ... 
데이터 크기 
(변수 개수만큼 반복/최대16) 
Data 의 Byte Size. 
데이터 
2 
데이터 크기 쓸 Data. 
포맷 
이름 
헤
더 
명령어 
데이터  
타입 
예약 
영역 
블록수
변수 
길이 
직접
변수
코드(예) .. h’0058 h’0002 h’0000 h’0001 h’0006 %MW
데이터 
개수 
.. 
데이터
..
 h’0002 h’1234
 100 
                                         1
 (1) 블록수 
블록(최대 16 블록 까지 반복 설정 가능) 
이것은 ‘[변수 길이][변수]’와 ‘[데이터 길이][데이터]’로 구성된 블록이 이 요구  
포맷에 몇 개가 있는지를 지정하는 것으로 최대 16개 블록까지 설정할 수 있습니다.  
따라서 [블록수]의 값은 h’01~ h’10 이어야 합니다. 
(2) 변수 길이(변수 이름 길이) 
변수를 의미하는 이름의 글자 수를 나타내는 것으로 최대 16자까지 허용됩니다.  
값의 범위는 h’01에서 h’10까지 입니다. 
11/21 
XGT FEnet I/F 모듈 프로토콜 규격 
(3) 변수 
실제로 쓰고자 하는 변수의 어드레스를 입력합니다. 16자 내의 아스키 값이어야 하며, 
변수 이름에는 숫자,대소문자 , ‘%’ 및 ’.’이외에는 허용되지 않습니다. 
알아두기 
1) 각 블록의 디바이스 데이터 타입은 반드시 동일하여야 합니다. 만일 첫번째 블록의 
데이터 타입은 Word 이고, 두번째 블록의 데이터 타입은 Double Word 라면 에러가 
발생합니다. 
2) 데이터 타입이 Bool 인 경우 읽은 데이터는 HEX 로 한 Byte 로 표시합니다. 즉 BIT 값이
0 이면 h’00으로, 1이면 h’01로 표시됩니다. 
3) 응답 포맷(PLC가 ACK 응답 시) 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
코드(예) 
... 
에러 
상태 
블록 수 
h’0059 h’0002 
(1) 블록수 
정상적으로 쓰여진 블록 수를 나타냅니다. 
4) 응답 포맷(NAK 응답 시) 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약 
영역 
h’0000 h’0000 
에러상태 
h’0001 
에러 코드 
(Hex 1 Byte) 
코드(예) 
... 
h’0059 h’0002 h’0000 
알아두기 
h’FFFF 
(0 이아닌값) 
h’21 
1) 에러 코드는 헥사로 1바이트의 내용으로 에러 종류를 표시합니다. 
자세한 내용은 ‘에러코드’를 참조하십시오. 
12/21 
XGT FEnet I/F 모듈 프로토콜 규격 
2.4 변수 연속 쓰기 
1) 개 요 
PLC 디바이스 메모리를 직접 지정하여 메모리에 데이터를 쓰는 기능입니다. 지정된 
번지부터 지정된 양 만큼의 데이터를 연속으로 쓰는 기능 입니다. 단, 바이트 형태의 변수만 
사용 가능 합니다. 
나) 요구포맷 
■ 연속변수 쓰기 요구 (MMI 
항 목 
크기(byte) 
 PLC) 
명령어 
내용 
2 
데이터 타입 
0x0058 : Write Request 
0x0014 : 블록 타입 
예약 영역 
2 
2 
0x0000 : Don’t Care. 
변수 개수 
쓰고자 하는 Variable의 개수. 0x0001 
변수명 길이 
2 
2 
Variable 명의 길이. 최대 16자. 
변수명 
변수명 길이 Variable 명. 바이트 타입 직접변수만 사용가능.  
(즉, %MB / %PB / %DB/….. 형태 가능: 
지원 디바이스:P,N,L,K,T,C,D,N )  
블록의 선두 번지를 나타냄. (예. %MB0, %PB0) 
데이터 
데이터 크기 쓰고자 하는 Data, 최대 1400byte 
포맷 
이름 
헤더 
명령어 
데이터
타입 
예약 
영역 
블록수
변수 
길이 
코드(예) 
... 
h’0058 h’0014 
변수 
데이터 
개수 
데이터
h’0000 h’0001 h’0006 %MB10
 0 
(1) 데이터 개수 
데이터의 바이트 개수를 의미합니다(최대 1,400 바이트). 
(2) 블록수 
이 값은 h’0001로만 사용할 수 있습니다. 
(3) 변수 길이 
h’0002 h’1234
변수를 의미하는 이름의 자 수를 나타내는 것으로 최대 16자까지 허용되고,  
범위는 h’01에서 h’10까지 입니다. 
(4) 변수 
실제로 쓸 변수의 어드레스를 말하며 16자 내의 아스키 값이어야 하고 변수 이름에는  
숫자, 대소문자 , ‘%’ 및 ’.’이외에는 허용되지 않습니다. PLC 타입에 따라 변수 연 
속 쓰기가 가능한 종류는 [표 10.3.2] 변수에 따른 데이터 개수를 참조하기 바랍니다. 
13/21 
XGT FEnet I/F 모듈 프로토콜 규격 
알아두기 
1) XGT 시리즈 각 디바이스의 영역 지정 방법은 해당 기술자료를 참조하여 주십시오. 
3) 응답 포맷(PLC ACK 응답 시) 
■ 연속 변수 읽기 응답 (PLC 
항 목 
크기(byte) 
MMI) 
내용 
명령어 
2 
데이터 타입 
0x0059 : Write Response 
0x0014 : 블록 타입 
예약 영역 
2 
2 
0x0000 : Don’t Care 
에러 상태 
2 
0 이면 정상,  0이 아니면 에러 
에러 정보
2 
 Error State 가 에러인 경우 하위 Byte가 에러 번호 
변수 개수  
0x0001 : Error State 가 정상인 경우  
포맷이름 
헤더 
명령어 
데이터 타입
예약영역 
에러상태 
코드(예) 
... 
블록수 
h’0059 h’0014 
h’0000 
(1) 데이터 타입 
가능한 데이터 타입은 바이트 타입(%MB,%IB,%QB)입니다. 
(2) 데이터 개수 
바이트(헥사) 개수를 의미합니다.  
4) 응답 포맷 (PLC NAK 응답 시) 
포맷 
이름 
헤더 
명령어 
데이터 
타입 
예약영역
h’0000 h’0001 
에러코드 
에러상태
코드(예) 
.... 
(Hex 1 Byte) 
h’0059 h’0014 h’0000 
(1) 에러 코드 
h’FFFF 
헥사로 1바이트의 내용으로 에러 종류를 표시합니다. 
자세한 내용은 ‘에러코드 표’를 참조하십시오. 
14/21 
h’21 
XGT FEnet I/F 모듈 프로토콜 규격 
 
15/21 
 
 
 
2.5 STATUS 읽기 요구 (MMI -> PLC) 
 
1) 개 요 
PLC 내의 정보 및 상태 등을 통신을 이용해서 사용할 수 있게 하는  서비스 입니다. 
 
2) 컴퓨터 요구 포맷 
항 목 크기(byte) 내 용 
명령어 2 0x00B0 : Status Request 
데이터 타입 2 0x0000 : Don’t Care 
예약 영역 2 0x0000 : Don’t Care 
 
3) 응답 포맷(PLC에서 ACK응답) 
항 목 크기(byte) 내 용 
명령어 2 0x00B1 : Status Response 
데이터 타입 2 0x0000 : Don’t Care 
예약 영역 2 0x0000 : Don’t Care 
에러 상태 2 0이면 정상,  0이 아니면 에러코드 
데이터 크기 2 0x0018 
데이터 24 Status Data 
 
4) XGT Status Data 구조 
항 목 크기 
(byte) 
Byte  
위치 내 용 
Slot Info 4 0 
슬롯 정보 
Bit00~Bit03 : 로컬이 다른 국으로 리모트 접속한 슬롯 정보
Bit04~Bit07 : 로컬이 다른 국으로 리모트 접속한 베이스
정보 
Bit08~Bit11 : 다른 국에서 리모트 접속한 슬롯 정보 
Bit12~Bit15 : 다른 국에서 리모트 접속한 베이스 정보 
Bit16~Bit19 : 본 모듈이 장착된 슬롯 정보 
Bit20~Bit23 : 본 모듈이 장착된 베이스 정보 
Bit24~Bit31 : Reserved 
_CPU_TYPE 2 4 시스템의 형태 플래그 
_VER_NUM 2 6 OS 버전 번호 플래그 
_SYS_STATE 4 8 PLC 모드와 운전상태 플래그 
_PADT_CNF 2 12 XG5000연결 상태 플래그 
_CNF_ER 4 14 시스템의 에러(중고장) 플래그 
_CNF_WAR 4 18 시스템의 경고 플래그 
Reserved 2 22 예약영역 
* 각 항목에 대한 상세 설명은 *플래그 설명 참조. 
XGT FEnet I/F 모듈 프로토콜 규격 
5) 플래그 설명 
▣ _CPU_TYPE 
15Bit : XGK(1)/XGI(0), 15Bit : 단독,이중화 마스터(0)/이중화 슬레이브(1) 
단독   : 0x8000~0xffff 
0xA001 : XGK-CPUH 
0xA002 : XGK-CPUS 
▣ _VER_NUM 
0xXXYY : xx.yy 
▣ _SYS_STATE 
시스템의 운전모드와 운전상태 정보를 표시합니다.(DWORD, F00~F01) 
변수 
타입 
디바이스 
기능 
_RUN Bit F00000 RUN 
설명 
_STOP Bit F00001 STOP 
CPU 모듈의 운전 상태가 RUN 중 
CPU 모듈의 운전 상태가 STOP 중 
_ERROR Bit F00002 ERROR 
CPU 모듈의 운전 상태가 ERROR 중 
_DEBUG Bit F00003 DEBUG 
CPU 모듈의 운전 상태가 DEBUG 중 
_LOCAL_CON Bit 
F00004 
로컬 컨트롤 
_MODBUS_CON Bit 
F00005 
모드 키에 의해서만 운전모드 변경이 가능 
모드버스 모드 On 
_REMOTE_CON Bit 
F00006 
모드 버스 슬레이브 서비스 중 
리모트 모드 On - Bit F00007 - 
리모트 모드에서 운전 중 - 
_RUN_EDIT_ST
 Bit 
F00008 
런중 수정 중 
(프로그램 다운로드중) 런중 수정 시 수정된 프로그램 대기 중 
_RUN_EDIT_CHK Bit 
F00009 
런중 수정 중 
(내부 처리 중) 
_RUN_EDIT_DONE Bit 
F0000A 
런중 수정 내부 처리중 
런중 수정 완료 
_RUN_EDIT_END Bit 
F0000B 
런중 수정이 정상적으로 끝남 
런중 수정 끝일 때  
아는 내부 플래그 런중 수정이 정상적으로 수행되었음 
_CMOD_KEY Bit F0000C 운전 모드 변경 요인 키에 의한 운전모드 변경 
_CMOD_LPADT
 Bit 
F0000D 
_CMOD_RPADT Bit 
운전 모드 변경 요인 로컬 PADT에 의한 운전모드 변경 
F0000E 
_CMOD_RLINK Bit 
운전 모드 변경 요인 리모트 PADT에 의한 운전모드 변경 
F0000F 운전 모드 변경 요인 리모트 통신 모듈에 의한 운전 모드 변경 
_FORCE_IN Bit F00010 강제 입력 
_FORCE_OUT
입력접점에 대한 강제 On/Off 실행 중 
 Bit 
F00011 
강제 출력 
출력접점에 대한 강제 On/Off 실행 중 
16/21 
XGT FEnet I/F 모듈 프로토콜 규격 
변수 
타입 
디바이스 
기능 
설명 
_SKIP_ON Bit F00012 입출력 Skip 실행 중 고장체크 및 데이터 리프레시를 중지하도록
지정된 입출력모듈이 있음 
_EMASK_ON Bit F00013 고장 마스크 실행 중 고장이 발생하여도 운전을 속행하도록
_MON_ON Bit F00014 모니터 실행 중 
지정된 입출력 모듈이 있음 
프로그램 및 변수에 대한 외부 모니터 실행
중 
_USTOP_ON Bit F00015 Stop 펑션에 의한
RUN 모드 운전 중 STOP 펑션에 의해 스캔
종료 후 정지 
Stop 
_ESTOP_ON Bit F00016 ESTOP 펑션에 의한
Stop 
RUN 모드 운전 중 ESTOP 펑션에 의해
즉시 정지 
_CONPILE_MODE Bit 
F00017 
컴파일중 
_INIT_RUN Bit 
컴파일 수행 중 
F00018 
초기화중 - Bit F00019 - 
초기화 태스크가 수행 중 - Bit F0001A - - - - - Bit F0001B - 
_PB1 Bit F0001C 프로그램 코드1 1번 프로그램 코드 수행 중 
_PB2 Bit F0001D 프로그램 코드2 2번 프로그램 코드 수행 중 
_CB1 Bit F0001E 컴파일 코드1 1번 컴파일 코드 수행 중 
_CB2 Bit F0001F 컴파일 코드2 2번 컴파일 코드 수행 중 
변수 
▣ _CNF_ER  
운전 중지 고장 관련 에러 플래그들을 일괄 표시 
타입 
디바이스 
기능 
_CPU_ER Bit F00020 CPU 구성 에러 
설명 
CPU 모듈의 자체진단 에러 발생으로
정상동작이 불가능 
_IO_TYER Bit F00021 모듈 타입 불일치  
각 슬롯의 I/O 구성 파라미터와 실제 장착
모듈의 구성이 서로 다른 경우 
에러 
_IO_DEER Bit F00022 모듈 착탈 에러 
운전 중 각 슬롯의 모듈 구성이 달라질
경우 이를 검출하여 표시 
_FUSE_ER Bit F00023 퓨즈 단선 에러 
각 슬롯의 모듈 중 Fuse 가 부착된 모듈의
Fuse 가 단선된 경우 이를 검출하여 표시 
_IO_RWER Bit F00024 입출력 모듈 읽기/ 
각 슬롯의 모듈 중 입출력 모듈을
정상적으로 읽기/쓰기를 할 수 없는 경우의
에러 발생시 표시 
쓰기 에러(고장) 
_IP_IFER Bit F00025 특수/통신 모듈  
각 슬롯의 모듈 중 특수 또는 통신 모듈의
오동작으로 인하여 정상적인 인터페이스가
불가능한 경우의 에러 발생시 표시 
인터페이스 에러(고장)
 _ANNUM_ER Bit F00026 외부기기의 중고장  
사용자 프로그램에 의해 외부기기의
중고장을 검출하여 ANC_ERR[n]에 기록한
경우 고장검출의 발생을 표시 
검출 에러 
17/21 
XGT FEnet I/F 모듈 프로토콜 규격 
 
18/21 
 
 
 
변수 타입 디바이스 기능 설명 - Bit F00027 - - 
_BPRM_ER Bit F00028 기본 파라미터 이상 기본 파라미터의 이상 유무를 체크 하여  
이상을 표시 
_IOPRM_ER Bit F00029 IO 구성 파라미터  
이상 
I/O구성 파라미터의 이상 유무를 체크 하여
 이상을 표시 
_SPPRM_ER Bit F0002A 특수 모듈 파라미터 
이상 
특수 모듈 파라미터의 이상 유무를 
체크하여 이상을 표시 
_CPPRM_ER Bit F0002B 통신 모듈 파라미터 
 이상 
통신 모듈 파라미터의 이상 유무를  
체크하여 이상을 표시 
_PGM_ER Bit F0002C 프로그램 에러 사용자 프로그램의 이상 유무를 체크 하여 
이상을 표시 
_CODE_ER Bit F0002D 프로그램 코드 에러 사용자 프로그램 수행 중 해독할 수 없는 
명령을 만났을 때 발생 
_SWDT_ER Bit F0002E 시스템 워치독 에러 시스템 감시 시간(System watchdog)을  
초과했을 때 발생 
_BASE_POWER_ 
ER Bit F0002F 전원 에러 베이스 전원에 이상이 있을 때 발생하는  
에러 
_WDT_ER Bit F00030 스캔 워치독 
프로그램의 스캔 타임이 파라미터에 의해 
지정한 스캔 지연 감시시간(Scan Watchdog 
Time)을 초과했을 때 발생하는 에러 -  F00031 
F0003F - - 
 
▣ _CNF_WAR   
운전 속행과 관련한 경고 플래그들을 일괄 표시(DWORD, F004~F005) 
변수 타입 디바이스 기능 설명 
_RTC_ER Bit F00040 RTC 데이터 이상 RTC의 데이터 이상 시 이를 표시 
_DBCK_ER Bit F00041 데이터 백업 이상 
백업 이상으로 데이터 메모리가 훼손되어, 
정상적인 (핫 또는) 웜 리스타트 프로그램 
수정이 불가능하여 콜드 리스타트를 수행한
경우, 이를 알리는 플래그로 초기화  
프로그램에서 사용 가능하며 초기화  
프로그램의 완료 시 자동으로 리셋 
_HBCK_ER Bit F00042 핫 리스타트 불가 에러 
_ABSD_ER Bit F00043 비정상 운전 정지 
프로그램 수행 중 전원 차단 등의 이유로 
프로그램이 중도에 정지한 후, 전원 재투입 
시 스캔 단위로 동기된 데이터를 보존한  
연속운전이 되지 못하였음을 경고하는  
플래그로 초기화 프로그램에서 사용가능 
하며 초기화 프로그램의 완료 시 자동으로 
XGT FEnet I/F 모듈 프로토콜 규격 
 
19/21 
 
리셋 
 
변수 타입 디바이스 기능 설명 
_TASK_ER Bit F00044 태스크 충돌 
사용자 프로그램 수행 시 동일한 태스크가 
중복으로 실행이 요청되는 경우에 태스크의
충돌을 표시하는 플래그 
_BAT_ER Bit F00045 배터리 이상 
사용자 프로그램 및 데이터 메모리의  
백업을 위한 배터리 전압이 규정 이하 일 
때 이를 검출하여 표시 
_ANNUM_ER Bit F00046 외부 기기의 경고장
검출 
사용자 프로그램에 의해 외부기기의  
경고장을 검출하여 ANC_WB[n]에 기록한  
경우, 고장 검출의 발생을 표시 
_LOG_FULL Bit F00047 로그 메모리 풀 경고PLC의 로그 메모리가 Full이 되었음을 
 표시 
_HS_WAR1 Bit F00048 HS 라미터1이상 
_HS_WAR2 Bit F00049 HS 라미터2이상 
_HS_WAR3 Bit F0004A HS 라미터3이상 
_HS_WAR4 Bit F0004B HS 파라미터4이상 
_HS_WAR5 Bit F0004C HS 파라미터5이상 
_HS_WAR6 Bit F0004D HS 파라미터6이상 
_HS_WAR7 Bit F0004E HS 파라미터7이상 
_HS_WAR8 Bit F0004F HS 파라미터8이상 
_HS_WAR9 Bit F00050 HS 파라미터9이상 
_HS_WAR10 Bit F00051 HS 파라미터10이상
_HS_WAR11 Bit F00052 HS 파라미터11이상
_HS_WAR12 Bit F00053 HS 파라미터12이상
고속링크 인에이블(Enable) 시 각 고속링크 
파라미터의 이상을 체크 하여 고속링크  
수행이 불가능할 때 이를 알리는 대표  
플래그로서 고속링크 디스에이블 시 리셋 
_P2P_WAR1 Bit F00054 P2P 파라미터 1 이상
_P2P_WAR2 Bit F00055 P2P 파라미터 2 이상
_P2P_WAR3 Bit F00056 P2P 파라미터 3 이상
_P2P_WAR4 Bit F00057 P2P 파라미터 4 이상
_P2P_WAR5 Bit F00058 P2P 파라미터 5 이상
_P2P_WAR6 Bit F00059 P2P 파라미터 6 이상
_P2P_WAR7 - F0005A P2P 파라미터 7 이상
_P2P_WAR8 - F0005B P2P 파라미터 8 이상
P2P 인에이블(Ena_le) 시 각 P2P  
파라미터의 이상을 체크 하여 P2P 수행이 
불가능할 때 이를 알리는 대표 플래그로서 
P2P 디스에이블시 리셋 
_Constant_ER - F0005C 고정주기 오류 스캔타임이 설정된 ‘고정주기’ 보다 큰 경우 
‘ON’ 됩니다 - - F0005D 
~F0005F - - 
 
 
 
XGT FEnet I/F 모듈 프로토콜 규격 
3. 모드버스/TCP 전용서버 
다른 기기 또는 상위 PC(MMI) 모드버스 마스터로 동작하는 경우 사용합니다. 
3.1 드라이버 설정 
모드버스 TCP 드라이버가 지원하는 모드버스 펑션과 응답 데이터의 최대 개수는 다음 
표와  
같습니다. 상대 마스터 기기는 다음 표의 범위 안에서만 요청을 해야 합니다. 예를 들어, 
비트 읽기 요청은 최대 2000비트까지이며, 비트 쓰기 요청은 최대 1600비트까지 가능 
합니다. 
코드 
내용 
01 
어드레스
응답크기 
Read Coil Status 
02 
0XXXX 
2000 Coils 
Read Input Status 
03 
1XXXX 
2000 Coils 
Read Holding Registers 
04 
4XXXX 
125 Registers 
Read Input Registers 
05 
3XXXX 
125 Registers 
Force Single Coil 
06 
0XXXX 
1 Coil 
Preset Single Register 
15 
4XXXX 
1 Register 
Force Multiple Coils 
16 
0XXXX 
1600 Coils 
Preset Multiple Registers 
4XXXX 
100 Registers 
위 Function Code 별 요청에 대해 XG-T PLC 메모리에 대한 매핑(Mapping)을 해줘야 합니다. 
각 설정 항목의 의미는 다음과 같습니다. 
항목 
의미 
DI 영역 주소 
비고 
디지털 입력 영역에 해당하는 XGT의 주소
 Bit 주소 
DO 영역 주소 디지털 출력 영역에 해당하는 XGT의 주소
AI 영역 주소 
 Bit 주소 
아날로그 입력 영역에 해당하는 XGT의 주소
 Word 주소 
AO 영역 주소 아날로그 출력 영역에 해당하는 XGT의 주소
각 항목에 설정한 주소 값은 해당 영역의 베이스 주소입니다. 
 Word 주소 
위 화면은 DI 영역을 MX1000부터 할당하고, AO영역을 PW200부터 할당한 경우입니다.  
20/21 
XGT FEnet I/F 모듈 프로토콜 규격 
베이스 어드레스 입력 값은 유효한 %M,P 등의 영역 내에 있어야 합니다. 모드버스의  
주소는 1 ~ 9999 (십진수) 이므로 비트 입, 출력 영역의 크기는 9999/8 = 124875  
바이트가 됩니다. 또, 워드 입, 출력 영역의 크기는 9999*2 = 19998 바이트 입니다.  
만약, 사용자가 비트 출력(0XXXX) 영역의 베이스 어드레스로 0을 설정했다면, 모드버스  
비트영역 00001은 0번째 바이트, 0번 비트에 대응되고, 00002은 0번째 바이트, 1번  
비트에 대응하게 됩니다.  
21/21